# Code Complete Notes

### 5. 关键的设计概念

1. 作为软件开发人员，我们不应该试着在同一时间把整个程序都塞进自己的大脑，而应该试着以某种方式去组织程序，以便能够在一个时刻可以专注于一个特定的部分。这么做的目的是尽量减少在任一时间锁要考虑的程序量。你可以把它想做是一种心理上的杂耍（边抛边接：通过轮流抛接使两个或两个以上物体同时保持与空中）—程序要求你保持的（精神上的）球越多，你就越可能漏掉其中的某一个，从而导致设计或者编码的错误。

2. 在软件架构的层次上，可以通过把整个系统分解为多个子系统来降低问题的复杂度。人类更容易理解许多项简单的信息，而不是一项复杂的信息。所有软件设计技术的目标都是把复杂问题分解为简单的部分。子系统间的相互依赖越少，你就越容易在同一时间里专注问题的一小部分。精心设计的对象关系使关注点相互分离，从而使你能在每个时刻只专注于一件事情。在更高汇聚的层次上，包提供了相同的好处。

3. 设计特征：

   **最小的复杂度**：应该做出简单且易于理解的设计；

   **易于维护**：这意味着在设计时为做维护工作的程序员考虑，设计出能自明（self-explanatory）的系统；

   **松散耦合**：这意味着在设计时让程序的各个组成部分之间关联最小。通过应用类接口中的合理抽象、封装性及信息隐藏等原则，设计出相互关联尽可能最少的类。减少关联也就减少了集成、测试与维护时的工作量；

   **可扩展性**：这是说在增强系统的功能而无须破坏其底层功能；

   **可重用性**：这意味着所设计的系统的组成部分能在其他系统中重复使用；

   **高扇入**：这是说大量的类使用某个给定的类，这意味着设计出的系统很好地利用了较底层次上的工具类（utility classes）；

   **低扇出**：这是说让一个类里少量或者适中地使用其他的类，高扇出（超过约 7 个）说明一个类使用了大量其他的类，因此可能变得过于复杂。无论考虑某个子程序调用其他子程序的量，还是考虑某个类使用其他类的量；

   **可移植性**：设计的系统很方便地移植到其他环境中；

   **精简性**：这意味着所设计的系统没有多余的部分。伏尔泰说，一本书的完成，不在于它不能再加入任何内容的时候，而在不能删除任何内容的时候。

   **层次性**：这意味着尽量保持系统各个分阶层的层次性，是你能在任意的层面上观察系统，并得到某种具有一致性的看法。设计出来的系统应该能在任意层次上观察而不需要进入其它层次。例如：在编写新系统时，其中用到很多设计不佳的旧代码，这是你就应该为新系统编一个负责同旧代码交互的层。在设计这一层时，要让它能隐藏旧代码的低劣质量，同时为新的层次提供一组一致的服务。这样，你的系统的其他部分就只需要与这一层进行交互，而无须直接同旧代码大交道了。

   **标准技术**：一个系统所依赖的外来的、古怪的东西越多，别人在第一次想要理解它的时候就越头疼。要尽量用标准化的、常用的方法，让整个系统给人一种熟悉的感觉。

4. 设计层次：**系统**首先被组织为**子系统**；子系统被进一步分解为**类**，然后类又被分解为**子程序和数据**；每个**子程序内部**也需要进行设计。

5. 在子系统这个层次设计时，不同子系统之间的相互通信的规则非常重要。如果所有子系统都能同其他子系统通信，就完全失去了把它们分开所带来的好处。应该通过限制子系统之间的通信来让每个子系统更有存在的意义。如果拿不准如何设计的话，那么应该先对子系统之间的通信加以限制，等日后需要时再放松。

6. 常用的子系统：

   **业务规则**：这是指在计算机系统中编入的规则以及过程；

   **用户界面**：用户界面组件应该同其他部分隔离开，以便使用户见面的演化不会破坏程序的其他部分；

   **数据库访问**：这可以把对数据库进行访问的实现细节隐藏起来，让程序的绝大部分可以不必关心处理底层结构的繁琐细节，并能像在业务层次一样处理数据。隐藏实现细节的子系统可以为系统提供有价值的抽象层，从而减少程序的复杂度。它把和数据库相关的操作集中起来，减少了在对数据进行操作时发生错误的几率。同时，它还能让数据库的设计结构更易于变化，做这种修改时无须修改程序的主要部分。

   **对系统的依赖性**：把对操作系统的依赖因素归到一个子系统里，就如同把对硬件的依赖因素封装起来一样。



### 7.高质量的子程序

子程序（routine）是为实现一个特定目的而编写的一个可被调用的方法（method）或者过程（procedure）。

常见子程序的正当理由：

1. 降低复杂度：通过子程序隐藏信息。除了在写子程序时要考虑子程序细节，完成以后应该忘记细节，毕竟一个普通人只能理解两万行左右代码。带来的好处还有：缩小代码规模，改善维护性，提高正确性。
2. 引入中间、易懂的抽象：把一段代码放入一个命名恰当的子程序内，是说明这代码用意的最好的方法之一。
3. 避免代码重复：这是最普遍的原因。如果在两段子程序内编写相似的代码，就以为中代码分解（decomposition）出现了差错。这时，应该把两段子程序中的重复代码提取出来，将其中的相同部分放入一个基类，然后再把两段程序中的差异代码放入派生类中。另一种办法是，你也可以把相同的代码放入新的子程序中，再让其余的代码来调用这个子程序。与代码重复出现相比，让相同的代码只出现一次可以节约空间。代码改动起来也更方便，因为只需要在一处修改即可。
4. 支持子类化（subclassing）：覆盖（override）简短而规整的子程序所需要新代码的数量，要比覆盖冗长而邋遢的子程序更少。
5. 隐藏顺序：把处理事件的顺序隐藏起来，如：有两行代码，先读取栈顶的数据，然后减少 stackTop 变量的值。你应该把这两行代码放到一个叫 PopStack() 的子程序中。从而把这两行代码所必须执行的顺序隐藏起来。把这种信息隐藏起来，比让它们在系统呢导出散布要好得多。
6. 隐藏指针操作：指针操作的可读性通常都很差，而且容易出错。通常把这些操作隔离在子程序内部，你就可以把精力集中于操作的意图本身，而不是指针操作的机理。
7. 提高可移植性：可以用子程序异常程序中不可移植的部分，从而明确识别和隔离未来的移植工作。不可移植部分包括，编程语言所提供的非标准功能、对硬件的依赖，以及对操作系统的依赖等。
8. 简化复杂的布尔判断：为了理解程序的流程，通常并没有必要去研究那些复杂的布尔判断的细节。应该把这些判断放入函数中，以提高代码的可读性，因为：（1）把判断的细节放到一边了，（2）一个具有描述性的函数名字可以概括出判断的目的。简化布尔判断也是降低复杂度的一个例子。放入函数或者简化为一句话，如多个指针判空，应当在使用前，整体做出判读，这样程序更简洁，单体写起来也更简练。
9. 改善性能：通过使用子程序，可以只在一个地方优化代码。代码集中在一处可以更方便地查出哪些代码的运行效率地下。
10. 确保所有的子程序都很小：小是相对的，在满足以上部分要求，在考虑程序大小。

把简单的重复出现的代码写成函数，因为简单的操作常常会变得复杂，比如操作参数的判断。如果写到一个函数中，那么只需要再一次修改就都修改好了。

理由总结：**降低复杂度，引入中间的、易懂的抽象，避免代码重复，支持子类化，隐藏顺序，隐藏指针操作，提高移植性，简化复杂的逻辑判断，改善新能；隔离复杂度，隐藏实现细节，限制变化所带来的影响，隐藏全局数据，形成中央控制点，促成可重用的代码，达到特定的重构目的**。